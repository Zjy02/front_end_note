# 垃圾回收机制 GC

## 内存管理

> 分三步

1. 分配你所需要的系统内存空间
2. 使用分配到的内存空间进行读写
3. 不需要使用内存时，将空间进行释放和归还

> js 会自动分配和回收空间

- 简单数据类型内存放在固定的栈空间中，可以通过值进行直接访问
- 引用数据类型的值大小不固定，其引用地址保存在栈空间，引用所指的值放在堆空间，需要通过引用进行访问
- 栈内的简单数据类型可以直接通过操作系统直接处理，而堆空间的引用类型的值不确定大小，需要通过 js 引擎通过垃圾回收机制处理

# 垃圾回收

> JavaScript 中主要的内存管理概念是 可达性，如果可以从任何一个已经定义的变量开始，直接或者通过其他对象的引用来访问到某个对象，则该对象是可达的。
> 在 JavaScript 引擎中有一个被称作垃圾回收器的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。

> 主要有两种回收算法

1. 标记清理
2. 引用标记

### 根

> JavaScript 中主要的内存管理概念是 可达性，如果可以从任何一个已经定义的变量开始，直接或者通过其他对象的引用来访问到某个对象，则该对象是可达的。
> 在浏览器中是 window 在 node 中是 global
> 在 JavaScript 引擎中有一个被称作垃圾回收器的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。
> 几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。

## 标记清理

> 标记清理分为两个阶段

1. 标记阶段
2. 清除阶段

   首先他会遍历堆内存里所有的对象，并为对象打上标记，然后再代码执行结束后，对使用过后的变量取消标记
   在清除阶段再把具有标记的对象进行整体清理，从而释放空间

> 优点是简单，但是会导致内存空间不是连续的，导致再次储存占较大的空间的对象产生影响，因此还需要通过表标记整理
> 策略进行解决

### 标记整理

> 标记整理算法在清除后对"活着"的对象，向内存的另一端移动最后清理掉边界内存

### 引用计数

> 对每一个值记录其引用次数

1. 当变量声明并赋值时，值的引用数为 1
2. 当同一个值赋给另一个变量时，值的引用数 +1
3. 当保存该值引用的变量被覆盖时，引用数 -1
4. 当引用数为 0 的时候，表示无法访问该值了，就进行清理和内存回收

   let a = new Object() // 此对象的引用计数为 1（a 引用）
   let b = a // 此对象的引用计数是 2（a,b 引用）
   a = null // 此对象的引用计数为 1（b 引用）
   b = null // 此对象的引用计数为 0（无引用）
   ... // GC 回收此对象

> 无法回收循环引用对象的内存，会造成内存泄漏”。即使我们将对象设置为 null，由于循环引用导致它的计数永远不为 0，因此内存不会被回收，造成内存泄漏

# v8 垃圾回收优化

> 使用分代式优化 GC

## 分代式垃圾回收

> v8 将堆内存分为两个区域，一，新生代，二，老生代,采用不同的垃圾回收器(副垃圾回收器，主垃圾回收器)
> 新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量
> 老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
> V8 整个堆内存的大小就等于新生代加上老生代的内存，对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控。

## 新生代内存回收 (副垃圾回收器)

- 分配的内存大小
  32 位系统 16M 内存
  64 位系统 32M 内存

> 新生代中的变量存活时间短，不太容易产生太大的内存压力
> 对于新生代的回收，采用 scavenge 算法，将新生代内存区域分为两部分：空闲区(to space)和使用区(form space)
> 实际运行的只有 form space, to space 处于空闲状态

- 原理
  在使用区空间快被写满的时候，进行垃圾回收。新生代的垃圾回收器会对 form sapce 的对象打上标记，标记完成之后将
  form space 的活跃的对象复制到 to space，进行排序，随后进行垃圾清理阶段，对使用区进行清理。清理完成后，将
  form space 和 to space 互换角色。循环

- 当一个对象复制多次还未被清理，该对象会被认为是声明周期长的对象，将其移动到老生代区域进行管理
  经历过一次 Scavenging 算法，且并未被标记清除的，也就是过一次翻转置换操作的对象。

- 在进行翻转置换时，被复制的对象大于 to space 空间的 25%。(from space 和 to space 一定是一样大的)会被放到
  老生代内存区域
  而 25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。

## 老生代内存回收(主垃圾回收器)

> 采用标记清理算法来清理垃圾，然用标记整理解决碎片化空间的问题

## 并行回收

> js 是单线程，在进行 GC 回收时会阻塞 js 脚本运行，导致系统停滞，等 GCC 回收结束时恢复，称为全停顿
> v8 为了解决这个问题采用并行回收的优化机制，在开启 GC 回收线程时，会同时开启多个辅助线程进行处理
> 避免系统卡顿时间过长

## 增量标记

> 全停顿标记策略在处理老生代垃圾回收时即使是有并行处理优化但是消耗时间也会消耗大量的时间，所以在 2011 年时 V8 团队又提出了增量标记策略来进行优化。
> 增量标记的思想是，将 GC 标记过程拆成一个个小部分，执行完毕就会继续执行脚本，执行一段脚本在进行执行刚刚拆分的 GC 标记任务，循环往复直至这次 GC 标记完成。

## 三色标记法

> 于是 V8 采用了 标记位 和 标记工作表 来实现标记。
> 标记位用来标记三种颜色：白色(00)、灰色(10)、黑色(11)，

      在 GC 标记开始时所有对象都是白色的，然后从根对象开始进行标记，先将这组对象标记为灰色然后进行记录，如果此时进行中断，后续恢复时既从灰色标记时开始即可，当回收器从标记工作表中弹出对象并访问他们的引用对象时，会将灰色置为黑色，同时将下一个引用对象置为灰色，继续往下进行标记工作。直至无可标记为灰色对象为止，此时表示 GC 标记过程结束，将所有未标记的变量进行回收工作。所以三色标记法可以渐进执行而不用每次执行都要全盘进行扫描整个内存空间，可以配合增量回收减少全停顿时间，提升体验。

## 写屏障

      现有 A、B、C 三个对象依次被引用，且在 GC 过程中已经被标记了，但是在暂停 GC 任务，插入执行程序任务之后，引用关系被改变了，新增了一个新变量 D，但是此时程序中也未存在灰色标记的变量，下一步进行清除机制时，新变量 D 按清除机制来讲是要被清除掉，但是这是极其不合理的，一个新的变量还存在引用就被回收掉，这会导致程序云行报错。此时写屏障机制就派上用场了，一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色，保证下一次的增量 GC 正确运行，这个机制称为强三色不变性(白色变量 D 被黑色变量 B 引用之后会被强制置灰保证程序运行正确性)。

## 惰性清理

      在增量GC标记之后下一步就是来真正回收内存空间，通过惰性清理来进行清除释放内存。惰性清理机制运行原理是在进行回收时如果内存足够就可以将这个回收清理时间稍微延迟一下，让JavaScript脚本先执行，清理时也不会一下全部清理掉所有的垃圾，会根据按需进行清理直至所有垃圾都回收完毕，然后继续等待下个GC标记阶段执行结束。

## 并发回收

> 虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是总体的停顿时间其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续 V8 团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行 GC 回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。

- 并发和并行的区别
  并行垃圾回收发生在主线程和工作线程上。应用程序在整个并行标记阶段暂停。
  并发垃圾回收主要发生在工作线程上。当并发垃圾回收正在进行时，应用程序可以继续运行。

## 空闲时垃圾回收

      空闲时垃圾回收并不属于Orinoco项目，是V8实现的一种优化策略。
      通常调度程序通过对任务队列占用率的了解，以及和V8其他组件接收到的信号，使它可以估计V8何时处于空闲状态，以及可能保持多长时间。利用这个信息，V8可以分配一些优先级不高的垃圾回收任务在这个空闲时间去做。
      比如V8会使用Chrome浏览器的task scheduler , 根据从Chrome其他各种组件接收到的信号以及旨在估算用户意图的各种启发式方法，动态地重新分配任务的优先级。例如，如果用户触摸屏幕，则调度程序将在100毫秒的时间段内优先处理屏幕渲染和输入任务，以确保用户界面在用户与网页交互时保持响应。
      例如，如果以60 FPS进行渲染，则帧间间隔为16.6 ms。如果没有在屏幕上进行任何有效的更新，则task scheduler 将启动更长的空闲时间，该空闲时间持续到启动下一个待处理任务为止，且上限为50毫秒，以确保Chrome保持对意外用户输入的响应。

## 如何判断 JavaScript 中内存泄漏的？

chrome 的 performance 观察一段时间，要是内存一直呈现上升趋势，就有可能是内存泄漏了。 最近工作中就遇到同事，对象自引用造成了栈溢出报错。

# 内存泄漏

> js 中分配内存的对象长期未进行内存释放和清理，造成长期占用，使得内存资源浪费，最终导致运行的应用程序响应速度
> 变慢以及崩溃

      在代码中创建对象和变量时会占据内存，但是 JS 基于自己的内存回收机制是可以确定哪些变量不再需要，并将其进
      行清除。但是，当你的代码中存在逻辑缺陷时，你以为你已经不需要，但是程序中还存在这引用，这就导致程序运行完
      后并没有进行合适的回收所占有的内存空间。运行时间越长占用内存越多，随之出现的问题就是：性能不佳、高延迟、
      频繁崩溃。

造成原因

      过多的缓存。及时清理过多的缓存。
      滥用闭包。尽量避免使用大量的闭包。
      定时器或回调太多。与节点或数据相关联的计时器不再需要时，DOM节点对象可以清除，整个回调函数也不再需要。可是，计时器回调函数仍然没有被回收（计时器停止才会被回收）。当不需要setTimeout或setInterval时，定时器没有被清除，定时器的糊掉函数以及其内部依赖的变量都不能被回收，会造成内存泄漏。解决方法：在定时器完成工作时，需要手动清除定时器。
      太多无效的DOM引用。DOM删除了，但是节点的引用还在，导致GC无法实现对其所占内存的回收。解决方法：给删除的DOM节点引用设置为null。
      **滥用全局变量。**全局变量是根据定义无法被垃圾回收机制进行收集的，因此需要特别注意临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，请确保将其指定为null或在完成后重新分配它。解决方法：使用严格模式。
      **从外到内执行appendChild。**此时即使调用removeChild也无法进行释放内存。解决方法：从内到外appendChild。
      反复重写同一个数据会造成内存大量占用，但是IE浏览器关闭后会被释放。
      注意程序逻辑，避免编写『死循环』之类的代码。
      DOM对象和JS对象相互引用。

## 如何检测内存泄漏

1.  F12 打开开发者工具
2.  选择 Performance 工具栏
3.  勾选屏幕截图和 Memory
4.  点击开始录制
5.  一段时间之后结束录制

堆内存会周期性地分配和释放
如果堆内存的 min 值在逐渐上升则存在内存泄漏

> 尽量不要再 for 循环中定义对象和函数
> 清空数组
