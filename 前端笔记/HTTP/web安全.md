# XSS 攻击

> xss 全称跨站脚本攻击

- 利用 html 可以执行<script>alert(1)</script>的特性，将脚本注入页面中的攻击手段

        一种是修改URL导致脚本注入
        另一种是通过输入框将脚本代码注入数据库

- 前一种会被 Chrome 浏览器自动防御攻击，后一种则需要手动防御，推荐使用 xx 库的白名单过滤方法

        const xss = require('xss')
        let html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
        // -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;

# CSRF 攻击

> 跨站请求伪造

- 分为 get 类型和 post 类型
- 原理：用户在 A 网站验证了用户信息，在没有退出 A 网站下，访问了恶意的 B 网站，B 网站接收到用户的请求后生成攻击代码，构造访问 A 网站的代码

## 防御 CSRF

1. 验证 referer
2. 验证 token

# 点击劫持

> 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌入自己的网页中，并将 iframe 设置为透明，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面

- 防御：

  在后端，使用 http 请求头 x-Frame-Options。
  x-Frame-Options 有三个可选值

        1. DENY：浏览器会拒绝当前页面加载任何frame页面；
        2. SAMEORIGIN：frame页面的地址只能为同源域名下的页面；
        3. ALLOW-FROM origin：允许frame加载的页面地址；

# 中间人攻击

> 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。中间人攻击的本质是客户端和服务端之间的认证和信任问题。

- 防御：

  对称加密、非对称加密、混合加密技术都没有有效防止中间人攻击，因为中间人可以截取首次传输的密钥并偷天换日，而客户端或服务端并无法得知。HTTPS 作为防止中间人攻击的终极手段，引入证书机制解决了客户端和服务端的信任问题，从而较为有效的防止了中间人攻击。对称加密、非对称加密、混合加密技术都没有有效防止中间人攻击，因为中间人可以截取首次传输的密钥并偷天换日，而客户端或服务端并无法得知。HTTPS 作为防止中间人攻击的终极手段，引入证书机制解决了客户端和服务端的信任问题，从而较为有效的防止了中间人攻击。
