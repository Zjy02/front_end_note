## 词法环境

> 词法环境对象由两部分组成

1. 环境记录:  一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。
2. 对外部词法环境的引用,与外部代码相关联。

> “词法环境”是一个规范对象（specification object）：它只存在于 语言规范 的“理论”层面，用于描述事物是如何工作的。我们无法在代码中获取该对象并直接对其进行操作。

> 一个函数其实也是一个值，就像变量一样。
> 不同之处在于函数声明的初始化会被立即完成。
> 当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 let 那样直到声明处才可用）。
> 正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 let say = function(name)


> 在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。

> 当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。

> 如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）
    
    function foo(){
      a = 10
    }

## 返回一个函数

    function makeCounter(){
      let count = 0

      return function (){
        return count++
      }
    }

    let counter = makeCounter()

> 在每次 makeCounter() 调用的开始，都会创建一个新的词法环境对象，以存储该 makeCounter 运行时的变量。
> 我们有两个嵌套词法环境 一个全局 一个makeCounter词法环境
> 不同的是，在执行 makeCounter() 的过程中创建了一个仅占一行的嵌套函数：return count++。我们尚未运行它，仅创建了它
> 所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 [[ Environment ]] 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。
> 因此，counter.[[ Environment ]] 有对 {count: 0} 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。[[ Environment ]] 引用在函数创建时被设置并永久保存
> 稍后，当调用 counter() 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 counter.[[ Environment ]]：
> 现在，当 counter() 中的代码查找 count 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 makeCounter() 的词法环境，并且在哪里找到就在哪里修改。
> 如果我们调用 counter() 多次，count 变量将在同一位置增加到 2，3 等

- 闭包
1. 闭包 是指一个函数可以记住其外部变量并可以访问这些变量。在某些编程语言中，这是不可能的，或者应该以一种特殊的方式编写函数来实现。但如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，Function）。

2. 也就是说：JavaScript 中的函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量

> v8的对于未使用的[变量的优化](https://zh.javascript.info/closure#shi-ji-kai-fa-zhong-de-you-hua)

## 参考
> [作用域和闭包](https://zh.javascript.info/closure#ci-fa-huan-jing)