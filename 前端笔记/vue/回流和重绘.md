# 回流

    几何属性变化
    当我们对 DOM 元素的修改引发元素尺寸的变化时，浏览器需要重新计算元素的大小和位置，最后将重新计算的结果绘制到屏幕上，这个过程被称为回流

## 触发回流的情况

1. 添加或删除可见的 DOM 元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
5. 页面一开始渲染的时候（这避免不了）
6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
7. 获取一些特定属性 offsetTop scrollLeft 等(获取这紫些属性时 浏览器会进行计算 所以要进行回流)

# 重绘

    元素样式变化
    当我们对 DOM 元素的修改值只改变元素的颜色时，浏览器此时并不需要重新计算元素的大小和位置，而只要重新绘制新样式。这个过程被称为重绘

## 触发重绘情况

-触发回流一定会进行重绘

1. 颜色的修改
2. 文本方向的修改
3. 阴影的修改

# 浏览器优化机制

    由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列
    当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据
    因此浏览器不得不清空队列，触发回流重绘来返回正确的值

# 如何减少重排

    我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：

    如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)
    避免设置多项内联样式
    应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)
    避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算
    对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响
    使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
    避免使用 CSS 的 JavaScript 表达式

    在使用 JavaScript 动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能

    我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作
