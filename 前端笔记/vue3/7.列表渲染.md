# v-for 

    我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名：

    const items = ref([{ message: 'Foo' }, { message: 'Bar' }])
    <li v-for="item in items">
    {{ item.message }}
    </li>

### 在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。

    <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
    </li>

### v-for 变量的作用域和下面的 JavaScript 代码很类似

    const parentMessage = 'Parent'
    const items = [
    /* ... */
    ]

    items.forEach((item, index) => {
    // 可以访问外层的 `parentMessage`
    // 而 `item` 和 `index` 只在这个作用域可用
    console.log(parentMessage, item.message, index)
    })

### 对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域：


    <li v-for="item in items">
    <span v-for="childItem in item.children">
        {{ item.message }} {{ childItem }}
    </span>
    </li>

### 你也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法：


    <div v-for="item of items"></div>

## v-for 与对象​
>你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。

    const myObject = reactive({
    title: 'How to do lists in Vue',
    author: 'Jane Doe',
    publishedAt: '2016-04-10'
    })
    <li v-for="(value, key, index) in myObject">
    {{ index }}. {{ key }}: {{ value }}
        </li>
## 在 v-for 里使用范围值​
>v-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1...n 的取值范围重复多次。

    <span v-for="n in 10">{{ n }}</span>
    注意此处 n 的初值是从 1 开始而非 0。


### <template> 上的 v-for​
>与模板上的 v-if 类似，你也可以在 <template> 标签上使用 v-for 来渲染一个包含多个元素的块.

## v-for 与 v-if
>当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：
    <!--
    这会抛出一个错误，因为属性 todo 此时
    没有在该实例上定义
    -->
    <li v-for="todo in todos" v-if="!todo.isComplete">
    {{ todo.name }}
    </li>
### 在外新包装一层 <template> 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)：

    <template v-for="todo in todos">
    <li v-if="!todo.isComplete">
        {{ todo.name }}
    </li>
    </template>

## 通过 key 管理状态
    Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。

    默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况
## 组件上使用 v-for

    我们可以直接在组件上使用 v-for，和在一般的元素上使用没有区别 (别忘记提供一个 key)：
    
    <MyComponent v-for="item in items" :key="item.id" />
    但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：
    <MyComponent
    v-for="(item, index) in items"
    :item="item"
    :index="index"
    :key="item.id"
    />

## 数组变化侦测
>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：

    push()
    pop()
    shift()
    unshift()
    splice()
    sort()
    reverse()

### 在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：

    diff
    - return numbers.reverse()
    + return [...numbers].reverse()